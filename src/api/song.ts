import {orderByValue, getDatabase, ref, set, update, push, child, get} from "firebase/database";
import log from "loglevel";
import {TurnModeState} from "../types";
import {Song, Note, BeatsSixteenths} from '../audio/types';
import * as util from "./util";

export type SongApiErrorCode =
  "unknown";
export type SongApiError = {
  description: string;
  code: SongApiErrorCode;
}

type DbNote = {
  startTime: {
    beat: number;
    sixteenth: number;
  },
  length: number;
};

type DbTrack = {
  instrumentId: string;
  notes: Record<string, DbNote>;
};

type DbPattern = {
  name: string;
  tracks: Record<string, DbTrack>;
}

type DbInstrument = {
  name: string;
  url: string;
};

export type DbSong = {
  name: string;
  timeSignature: {
    top: number;
    bottom: number;
  },
  instruments: Record<string, DbInstrument>,
  patterns: Record<string, DbPattern>,
  sheet: Record<string, boolean>,
};

const defaultDbSong: DbSong = {
  name: "New Song",
  timeSignature: {top: 4, bottom: 4},
  instruments: {
    '1': {
      name: 'kick',
      url: 'kick(2).wav',
    },
    '2': {
      name: 'clap',
      url: 'clap.wav',
    },
  },
  patterns: {
    '1': {
      name: 'drums',
      tracks: {
        '1': {
          instrumentId: '1',
          notes: {
            '1': {
              startTime: {
                beat: 0,
                sixteenth: 0,
              },
              length: 0.1,
            }
          },
        },
      },
    }
  },
  sheet: {},
}

export let songFromServer: Song = {
  id: '1',
  name: 'Beat 1',
  // TODO: should probably move this to patterns to allow each pattern to have its own timeSignature 
  timeSignature: [4, 4],
  instruments: [
    {
      id: '1',
      name: 'kick',
      url: 'kick(2).wav',
    },
    {
      id: '2',
      name: 'clap',
      url: 'clap.wav',
    }
  ],
  patterns: [
    {
      id: '1',
      name: 'drums',
      tracks: [
        {
          id: '1',
          instrumentId: '1',
          sequence: [
            {id: '1', startTime: [0, 0], length: 0.1},
            {id: '2', startTime: [1, 0], length: 0.1},
            {id: '3', startTime: [2, 0], length: 0.1},
            {id: '4', startTime: [3, 0], length: 0.1},
            {id: '5', startTime: [3, 2], length: 0.1},
          ],
        },
        {
          id: '2',
          instrumentId: '2',
          sequence: [
            {id: '6', startTime: [1, 0], length: 0.1},
            {id: '7', startTime: [3, 0], length: 0.1},
          ],
        }
      ],
    },
  ],
  sheet: {},
};

function dbSongToSong(dbSong: DbSong, id: string): Song {
  const instruments = util.fbMapToIdArr(dbSong.instruments);
  const patternsNoTracks = util.fbMapToIdArr(dbSong.patterns)
  const patterns = patternsNoTracks.map(p => {
    return {
      ...p,
      tracks: util.fbMapToIdArr(p.tracks).map(t => {
        return {
          ...t,
          sequence: util.fbMapToIdArr(t.notes).map(n => ({
            ...n,
            startTime: [n.startTime.beat, n.startTime.sixteenth] as [number, number],
          })),
        }
      }),
    }
  });
  return {
    id,
    name: dbSong.name,
    timeSignature: [dbSong.timeSignature.top, dbSong.timeSignature.bottom],
    instruments,
    patterns,
    sheet: {},
  }
}

export default {
  async get(songId: string): Promise<Song | null> {
    const db = getDatabase();
    const songRef = ref(db, `songs/${songId}`);
    const snapshot = await get(songRef);
    const val = snapshot.val() as DbSong;
    if (!val) {
      return null;
    }
    return dbSongToSong(val, songId);
  },
  async create(groupId: string, userId: string): Promise<Song> {
    const db = getDatabase();

    // Get a key for a new Group.
    const newSongKey = push(child(ref(db), 'songs')).key;
    if (!newSongKey) {
      log.warn(`No key for new song being generated by Firebase`);
      throw Error();
    }
    const turnMode: TurnModeState = {
      activeUserId: userId,
      songId: newSongKey,
    };

    const updates = {} as Record<string, any>;
    updates[`/songs/${newSongKey}`] = defaultDbSong;
    updates[`/groups/${groupId}/turnMode`] = turnMode;

    await update(ref(db), updates)
      .catch(fbErr => {
        log.error(fbErr);
        const e: SongApiError = {
          description: "Error with Firebase",
          code: "unknown",
        };
        throw e;
      });
    return dbSongToSong(defaultDbSong, newSongKey); 
  },
  update(song: Song): Promise<void> {
    log.warn("Not implemented!");
    songFromServer = song;
    if (song.id === '1') {
      return Promise.resolve();
    }
    return Promise.reject();
  },
  addInstrument(songId: string, instrumentId: string): Promise<void> {
    log.warn("Not implemented!");
    return Promise.resolve();
  },
  addSample(name: string, file: File): Promise<void> {
    log.warn("Not implemented!");
    if (!(file.name && file.size)) {
      log.error(`Not a valid file. Name: ${file.name}, Size: ${file.size}.`);
      return Promise.reject();
    }

    return Promise.resolve();
  },
  async updateSequence(songId: string, patternId: string, trackId: string, sequenceId: string, startTime: BeatsSixteenths, length: number): Promise<void> {
    const db = getDatabase();
    const data = {
      startTime: {
        beat: startTime[0],
        sixteenth: startTime[1],
      },
      length,
    };
    const updates = {
      [`/songs/${songId}/patterns/${patternId}/tracks/${trackId}/notes/${sequenceId}`]: data,
    };
    await update(ref(db), update)
      .catch(fbErr => {
        log.error(fbErr);
        const e: SongApiError = {
          description: "Error with Firebase",
          code: "unknown",
        };
        throw e;
      });
  },
}

